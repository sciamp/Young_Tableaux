/* Copyright (C) 2013 by Alessandro Campagni */

/*
 * This file is part of YoungTableaux.                                        
 *     YoungTableau is free software: you can redistribute it and/or modify   
 *     it under the terms of the GNU General Public License as published by   
 *     the Free Software Foundation, either version 3 of the License, or      
 *     (at your option) any later version.                                    
 *                                                                            
 *     YoungTableaux is distributed in the hope that it will be useful,       
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of         
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          
 *     GNU General Public License for more details.                           
 *                                                                            
 *     You should have received a copy of the GNU General Public License      
 *     along with YoungTableaux.  If not, see <http://www.gnu.org/licenses/>.
 *
 *
 * Author: Alessandro Campagni <alessandro@lilik.it>
 */

defstruct (ytableau (word));

new_ytableau_safe (l) := block (
  [w],
  w : ytableauwordp (l),
  yt : false,
  if listp (w) then yt : new (ytableau (w)),
  yt);

/* let's check if the list w is a suitable word for some tableau */
ytableauwordp (w) :=
if listp (w) then block (
  rows : makelist (),
  for i:1 unless emptyp (w) do block (
    top : pop (w),
    /* errcatch returns an empty list in case of error, so */
    /* if some rows exist we get the list containing a list which represents */
    /* the last row, if rows is empty we get an empty list (i.e. a new row!) */
    lastrow : errcatch (backpop (rows)),
    /* print (lastrow), */
    if not emptyp (lastrow) then lastrow : first (lastrow),
    /* print (lastrow), */
    if top >>= lastrow then block (
      lastrow : append (lastrow, makelist (top)),
      rows : append (rows, makelist (lastrow)))
    else block (
      rows : append (rows, makelist (lastrow)),
      rows : append (rows, makelist (makelist (top))))),
  if rows = sort (rows, 'lengthlessp) then rows
  else false
) else false;

ytableaup (t) :=
if listp (t@word) then block (
  [l,w],
  l : makelist (),
  for i : 1 thru length (t@word) do
  if listp (t@word[i]) then l : append (l, t@word[i]),
  w : ytableauwordp (l),
  if listp (w) then return (true))
else false;

/* l should be a tableau word, if given as a string */
/* as i'm not always in the mood of entering a list of integers! */
/* should be map ('parse_string, charlist ("5644623551223")) */
ytableau_from_word (l,t) :=
if ((not emptyp (l)) and (not emptyp (t))) then block (
  if (last (t[1])) <= l[1] then block (
    t[1] : append (t[1], [l[1]]),
    return (ytableau_from_word (rest (l, 1), t)))
  else block (
    t : append ([[l[1]]], t),
    return (ytableau_from_word (rest (l, 1), t))))
else if (not emptyp (l)) then block (
  t : [[l[1]]],
  return (ytableau_from_word (rest (l, 1), t)))
else reverse (t);

/* we could use flatten, this is the implementation */
/* of the algorithm from W.Fulton 'Young Tableaux' */
word_from_ytableau (l, t) :=
if (not emptyp (t)) then word_from_ytableau (append (l, t[1]), rest (t, 1))
else l;

ytableau_bump (T, x) := block (
  appended : false,
  for i : length (T@word) step -1 while (i > 0 and not appended) do block (
    bumped : false,
    if x < last (T@word[i]) then block (
      for j : 1 unless (j>length (T@word[i])) or bumped do
      if x < (T@word[i])[j] then block (
        tmp : x,
        x : (T@word[i])[j],
        (T@word[i])[j] : tmp,
        bumped : true))
    else block (
      T@word[i] : append (T@word[i], [x]),
      appended : true)),
  if not appended then block ( 
    w : T@word,
    T@word : push ([x], w)),
  return (T));

/* rb should be [r, x] where x is the element that is being bumped */
/* in the row r */
/* i should be length (r) */
/* rec_bump_row returns [bumped_row, next_x] or [append (r,[x]), 0]  */
rec_bump_row (r, x, i) :=
if (x >= last (r)) then [append (r, [x]), 0] /* r[i] <= r[i+1] */
else if ((i > 0) and (x < r[i])) then rec_bump_row (r, x, i-1)
else block (
  [next_x],
  next_x : r[i+1],
  r[i+1] : x,
  return ([r, next_x]));

/* t should be T@word */
/* i should be length (t) */
rec_ytableau_word_bump (t, x, i) :=
if (x > 0) then block (
  [],
  if (i > 0) then block (
    [next_b],
    next_b : rec_bump_row (t[i], x, length (t[i])),
    t[i] : next_b[1],
    return (rec_ytableau_word_bump (t, next_b[2], i-1)))
  else return (append ([[x]], t)))
else t;

/* T should be a tableau, x a positive integer */
recursive_ytableau_bump (T, x) := new (ytableau (rec_ytableau_word_bump (T@word, x, length (T@word))));

/* (i,j) should be (1,1) */
rec_ytableau_word_prod (t, u, u_len, i, j) :=
if ((i <= u_len) and (j <= length (u[i]))) then rec_ytableau_word_prod (
  rec_ytableau_word_bump (t, u[i][j], length (t)), u, u_len, i, j+1)
else if ((i <= u_len) and (j > length (u[i]))) then rec_ytableau_word_prod (t, u, u_len, i+1, 1)
else t;

/* s should be the word of a skew tableau */
/* s_len should be length(s) */
/* (i,j) should be (1,1) unless YOU KNOW WHAT YOU'RE DOING! */
next_inner_corner (s, s_len, i, j) :=
if (i <= s_len) then block (
  [],
  if (s[i][1] > 0) then return (next_inner_corner (s, s_len, i+1, 1)) /* no inner corner in this line */
  else if (j < length (s[i]) and s[i][j+1] > 0) then return ([i, j]) /* we got an inner corner */
  else if (j < length (s[i]) and s[i][j+1] = 0) then return (next_inner_corner (s, s_len, i, j+1))
  else if (j = length (s[i])) then return (false)) /* s[i] is filled only with zeros, */
                                                  /* hence there are no more inner corner */
else false; /* no inner corner in s */

/* s should be a skew tableau */
/* (i,j) should be next_inner_corner (s, s_len, 1, 1) */
jeu_de_taquin (s, i, j) :=
if ((i > 1) and (j < length (s[i])) and (j <= length (s[i-1]))) then block ( /* we're not on the border */
  if (s[i][j+1] < s[i-1][j]) then block ( /* slide to the rigth */
    s[i][j] : s[i][j+1],
    s[i][j+1] : 0,
    return (jeu_de_taquin (s, i, j+1)))
  else block ( /* slide below */
    s[i][j] : s[i-1][j],
    s[i-1][j] : 0,
    return (jeu_de_taquin (s, i-1, j))))
else if (((i > 1) and (j = length (s[i])) and (j > length (s[i-1]))) or ((i = 1) and (j = length (s[1])))) then block ( /* outside corner */
  s[i] : rest (s[i], -1),
  if (emptyp (s[i])) then s : delete ([], s),
  return (s))
else if ((i > 1) and (j = length (s[i])) and (j = length (s[i-1]))) then block (
  s[i][j] : s[i-1][j],
  s[i-1][j] : 0,
  return (jeu_de_taquin (s, i-1, j)))
else if ((i = 1) and (j < length (s[1]))) then block (
  s[1][j] : s[1][j+1],
  s[1][j+1] : 0,
  return (jeu_de_taquin (s, 1, j+1)))
else if ((i > 1) and (j > length (s[i-1]))) then block (
  s[i] : append (makelist (s[i][k], k, 1, j-1), makelist (s[i][k], k, j+1, length (s[i]))),
  if (emptyp (s[i])) then s : delete ([], s),
  return (s));

/* s should be a skew tableau word */
rect (s) := block (
  [corner],
  corner : next_inner_corner (s, length (s), 1, 1),
  if (corner = false) then return (s)
  else return (rect (jeu_de_taquin (s, corner[1], corner[2]))));

/* t and u should be tableau words */
prod_rect_word (t, u) := block (
  [t_width, u_height, zeros],
  t_width : length (last (t)),
  u_height : length (u),
  zeros : makelist (0, i, 1, t_width),
  return (rect (append (t, map (lambda ([x], append (zeros, x)), u))))); 

ytableaux_product (T,U) := block (
  /* WARNING! R : T creates a reference to T, not a copy! */
  R : new (ytableau (copylist (T@word))), /* we return a new tableau R = T*U */
  for i : 1 thru length (U@word) do
  for j : 1 thru length (U@word[i]) do ytableau_bump (R, U@word[i][j]),
  return (R));

/* The transpose of a tableau need not to be a tableau, so we're */
/* using simple lists instead of tableaux. Input list should be */
/* a list of lists. */
/* l should be [] */
remove_tableau_column (t, l) :=
if emptyp (t) then return (l)
else block (
  [current_line, next_t],
  current_line : reverse (maplist (lambda ([x], first (x)), t)),
  next_t : maplist (lambda ([x], rest (x, 1)), t),
  next_t : delete ([], next_t),
  return (remove_tableau_column (next_t, append ([current_line], l))));

ytableau_transpose (T) := remove_tableau_column (T@word, []); 
