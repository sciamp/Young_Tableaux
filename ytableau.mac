defstruct (ytableau (word));

new_ytableau_safe (l) := block (
  w : ytableauwordp (l),
  yt : false,
  if listp (w) then yt : new (ytableau (w)),
  yt);

/* let's check if the list w is a suitable word for some tableau */
ytableauwordp (w) :=
if listp (w) then block (
  rows : makelist (),
  for i:1 unless emptyp (w) do block (
    top : pop (w),
    /* errcatch returns an empty list in case of error, so */
    /* if some rows exist we get the list containing a list which represents */
    /* the last row, if rows is empty we get an empty list (i.e. a new row!) */
    lastrow : errcatch (backpop (rows)),
    /* print (lastrow), */
    if not emptyp (lastrow) then lastrow : first (lastrow),
    /* print (lastrow), */
    if top >>= lastrow then block (
      lastrow : append (lastrow, makelist (top)),
      rows : append (rows, makelist (lastrow)))
    else block (
      rows : append (rows, makelist (lastrow)),
      rows : append (rows, makelist (makelist (top))))),
  if rows = sort (rows, 'lengthlessp) then rows
  else false
) else false;

ytableaup (t) :=
if listp (t@word) then block (
  l : makelist (),
  for i : 1 thru length (t@word) do
  if listp (t@word[i]) then l : append (l, t@word[i]),
  w : ytableauwordp (l),
  if listp (w) then return (true))
else false;

ytableau_bump (T, x) := block (
  appended : false,
  for i : length (T@word) step -1 while (i > 0 and not appended) do block (
    bumped : false,
    if x < last (T@word[i]) then block (
      for j : 1 unless (j>length (T@word[i])) or bumped do
      if x < (T@word[i])[j] then block (
        tmp : x,
        x : (T@word[i])[j],
        (T@word[i])[j] : tmp,
        bumped : true))
    else block (
      T@word[i] : append (T@word[i], [x]),
      appended : true)),
  if not appended then block ( 
    w : T@word,
    T@word : push ([x], w)),
  return (T));

ytableaux_product (T,U) := block (
  /* WARNING! R : T creates a reference to T, not a copy! */
  R : new (ytableau (copylist (T@word))), /* we return a new tableau R = T*U */
  for i : 1 thru length (U@word) do
  for j : 1 thru length (U@word[i]) do ytableau_bump (R, U@word[i][j]),
  return (R));